import jax
jax.config.update("jax_enable_x64", False)  # float32 positions/velocities/mass

import jax.numpy as jnp
from jax import jit, lax, random, value_and_grad
from jax_md import units, quantity, space, partition, simulate
from energy_oplsaa import optimized_opls_aa_energy_with_nlist_modular
from extract_params_oplsaa import parse_lammps_data
from modular_Ewald import PME_Coulomb, make_is_14_lookup
import numpy as np
import pandas as pd
import os
from jax_md.util import f64

# === Load system ===
positions, bonds, angles, torsions, impropers, nonbonded, molecule_id, box, masses, atom_types = parse_lammps_data(
    'system_after_lammps_min.data',
    'EC.settings'
)

unit = units.real_unit_system()
charges, sigmas, epsilons, pair_indices, is_14_mask = nonbonded
bond_idx, k_b, r0 = bonds
angle_idx, k_theta, theta0 = angles
box_size = box
cut_off_radius = 15.0
dR = 0.5

positions = positions.astype(jnp.float32)
mass = jnp.array(masses).reshape(-1).astype(jnp.float32) * unit['mass']

displacement_fn, shift_fn = space.periodic_general(box, fractional_coordinates=False)

# --- Neighbor list setup ---
neighbor_fn = partition.neighbor_list(
    displacement_fn, box, r_cutoff=cut_off_radius,
    dr_threshold=dR,
    mask=True,
    return_mask=True
)
nlist_active = neighbor_fn.allocate(positions)

n_atoms = positions.shape[0]
is_14_table = make_is_14_lookup(pair_indices, is_14_mask, n_atoms)

# Exclusions
exclusion_mask = jnp.zeros((n_atoms, n_atoms), dtype=bool)
bond_same_mol = molecule_id[bond_idx[:, 0]] == molecule_id[bond_idx[:, 1]]
angle_same_mol = molecule_id[angle_idx[:, 0]] == molecule_id[angle_idx[:, 2]]
bond_idx_filtered = bond_idx[bond_same_mol]
angle_idx_filtered = angle_idx[angle_same_mol]
exclusion_mask = exclusion_mask.at[bond_idx_filtered[:, 0], bond_idx_filtered[:, 1]].set(True)
exclusion_mask = exclusion_mask.at[bond_idx_filtered[:, 1], bond_idx_filtered[:, 0]].set(True)
exclusion_mask = exclusion_mask.at[angle_idx_filtered[:, 0], angle_idx_filtered[:, 2]].set(True)
exclusion_mask = exclusion_mask.at[angle_idx_filtered[:, 2], angle_idx_filtered[:, 0]].set(True)

# === Energy functions ===
# === Coulomb Handler ===
coulomb_handler = PME_Coulomb(grid_size=32, alpha=0.16219451)

# === Build force field ===
bonded_lj_fn_factory_full, _, _ = optimized_opls_aa_energy_with_nlist_modular(
    bonds, angles, torsions, impropers,
    nonbonded, molecule_id, box_size,
    use_soft_lj=False, exclusion_mask=exclusion_mask, is_14_table=is_14_table
)
def make_energy_fn(bonded_lj_factory, coulomb_handler,
                   charges, box_size, exclusion_mask, is_14_table):
    def energy_fn(R, nlist, box, **kwargs):
        _, _, _, _, _, E_bonded_lj = bonded_lj_factory(R, nlist)
        _, _, _, E_coulomb = coulomb_handler.energy(
            R, charges, box_size, exclusion_mask, is_14_table, nlist
        )
        return E_bonded_lj + E_coulomb
    return jit(energy_fn)

energy_fn = make_energy_fn(
    bonded_lj_fn_factory_full, coulomb_handler,
    charges, box_size, exclusion_mask, is_14_table
)
energy_grad_fn = jit(value_and_grad(energy_fn))

# --- NPT parameters ---
dt = 0.5 * unit['time']
tau_T = 500.0 * unit['time']
tau_P = 5000.0 * unit['time']
T_init = 298.0 * unit['temperature']
P_init = 1.0 * unit['pressure']
key = random.PRNGKey(121)
steps = 1000

from typing import Dict
def default_nhc_kwargs(tau: f64, overrides: Dict) -> Dict:
    base = {'chain_length': 3, 'chain_steps': 1, 'sy_steps': 1, 'tau': tau}
    return {**base, **(overrides or {})}

new_kwargs = {'chain_length': 3, 'chain_steps': 1, 'sy_steps': 1}

init, apply = simulate.npt_nose_hoover(
    energy_fn=energy_fn,
    shift_fn=shift_fn,
    dt=dt,
    pressure=P_init,
    kT=T_init,
    barostat_kwargs=default_nhc_kwargs(tau_P, new_kwargs),
    thermostat_kwargs=default_nhc_kwargs(tau_T, new_kwargs)
)

state = init(key, positions, nlist=nlist_active, mass=mass, box=box)

# --- Output files ---
trajectory_xyz_file = "trajectory.xyz"
thermo_file = "thermo.csv"
for f in [trajectory_xyz_file, thermo_file]:
    if os.path.exists(f):
        os.remove(f)

def save_xyz(frames, atom_types, file_path):
    with open(file_path, "a") as f:
        for frame in frames:
            f.write(f"{len(atom_types)}\n")
            f.write("Generated by JAX MD simulation\n")
            for atom_type, pos in zip(atom_types, frame):
                f.write(f"{atom_type} {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")

# --- Chunked scan parameters ---
write_every = 10
nlist_update_steps = 10
chunk_size = 20  # number of steps per JIT-compiled scan

thermo_records = []

@jit
def scan_chunk(carry, _):
    state, nlist, counter = carry

    def step_fn(carry_inner, _):
        state_inner, nlist_inner, counter_inner = carry_inner

        # Neighbor list update
        nlist_inner = lax.cond(counter_inner == 0,
                               lambda nl: nl.update(state_inner.position),
                               lambda nl: nl,
                               nlist_inner)
        counter_inner = lax.cond(counter_inner == 0,
                                 lambda _: nlist_update_steps,
                                 lambda _: counter_inner - 1,
                                 operand=None)
        state_inner = apply(state_inner, nlist=nlist_inner)
        return (state_inner, nlist_inner, counter_inner), None

    carry, _ = lax.scan(step_fn, (state, nlist, counter), None, length=chunk_size)
    return carry, carry[0].position  # return last positions for logging

# --- Main loop over steps ---
total_chunks = steps // chunk_size
counter = nlist_update_steps

for chunk_idx in range(total_chunks):
    (state, nlist_active, counter), positions_out = scan_chunk((state, nlist_active, counter), None)

    # Stream outputs every write_every steps
    for step_in_chunk in range(chunk_size):
        global_step = chunk_idx * chunk_size + step_in_chunk
        if global_step % write_every == 0:
            mom = state.velocity * mass[:, None]
            T = quantity.temperature(momentum=mom, mass=mass[:, None])
            KE = quantity.kinetic_energy(momentum=mom, mass=mass[:, None])
            PE, _ = energy_grad_fn(state.position, nlist_active, box)
            thermo_records.append((global_step, float(T), float(KE), float(PE)))
            save_xyz([np.array(state.position)], atom_types, trajectory_xyz_file)

# --- Save thermo ---
df = pd.DataFrame(thermo_records, columns=["step", "kT", "KE", "PE"])
df.to_csv(thermo_file, index=False)

R_final = state.position
E_final, _ = energy_grad_fn(R_final, nlist_active, box)
print(f"Total final potential : {E_final:.6f} kcal/mol")
print(f"Trajectory saved to {trajectory_xyz_file}, thermo data saved to {thermo_file}")

